import numbers

import numpy as np

from functools import singledispatchmethod

import ir

from errors import CompilerError
from utils import unpack_iterated
from visitor import ExpressionVisitor, StmtVisitor


def array_arg_from_spec(ndims, dtype, fixed_dims=()):
    """
    Parameterized array type suitable for use as an argument.
    evol can be None, sliding window, and iterated (just advance iterator by one each time),
    with any subscript applied to a sliding window being folded into the variable's evolution.

    dims should be a dense map, tuple of key, value pairs

    """
    if dtype is None:
        msg = f"Cannot map None to dtype"
        raise CompilerError(msg)
    ir_dtype = ir.by_input_dtype.get(dtype)
    if ir_dtype is None:
        # check if this is coercible to dtype
        ir_dtype = ir.by_input_dtype.get(np.dtype(dtype))
    if ir_dtype is None:
        msg = f"Unsupported dtype {ir_dtype}."
        raise CompilerError(msg)
    # should be a tuple of pairs
    seen = set()
    for index, value in fixed_dims:
        if index in seen:
            msg = f"index {index} is duplicated."
            raise CompilerError(msg)
        seen.add(index)
        if not isinstance(index, numbers.Integral):
            msg = f"dims can only be used to specify fixed dimensions, received: {value}."
            raise CompilerError(msg)
        elif 0 > value:
            msg = f"Negative dim {value} specified"
            raise CompilerError(msg)
        elif index >= ndims:
            msg = f"dim {index} specified for array with {ndims} dimensions."
            raise CompilerError(msg)
    return ir.ArrayType(ndims, ir_dtype)


def truth_type_from_type(t):
    tt = ir.truth_type_table.get(t)
    if tt is None:
        msg = f"No truth type corresponds to type {t}."
        raise CompilerError(msg)
    return tt


def int_from_spec(bits, signed):
    assert isinstance(bits, int)
    if signed:
        t = ir.IntegerType(bits)
    else:
        t = ir.UnsignedType(bits)
    if t not in ir.supported_types:
        msg = f"Integer with parameters signed={signed} bits={bits} does not have a supported type."
        raise CompilerError(msg)
    return t


def float_from_spec(bits):
    assert isinstance(bits, int)
    t = ir.FloatType(bits)
    if t not in ir.supported_types:
        msg = f"Integer with parameters bits={bits} does not have a supported type."
        raise CompilerError(msg)
    return t


def predicate_from_spec(bits):
    assert isinstance(bits, int)
    t = ir.PredicateType(bits)
    if t not in ir.supported_types:
        msg = f"Predicate type with parameters bits={bits} does not have a supported type."
        raise CompilerError(msg)
    return t


def merge_truth_types(types):
    assert len(types) > 0 and all(isinstance(t, ir.PredicateType) for t in types)
    bit_width = 0
    for t in types:
        if not isinstance(t, ir.PredicateType):
            # check that each intermediate type is in fact a supported type
            t = predicate_from_spec(t.bits)
        bit_width = max(bit_width, t.bits)
    t = predicate_from_spec(bit_width)
    return t


class ExprTypeInfer(ExpressionVisitor):
    """
    This exists to determine the output types generated by expressions. Actual inference
    injects greater ambiguity here.

    references:
    Ole Ageson, The Cartesian Product Algorithm
    Simple and Precise Type Inference of Parametric Polymorphism

    """

    def __init__(self, symbols):
        # types updated externally
        self.symbols = symbols

    def __call__(self, node):
        assert isinstance(node, ir.ValueRef)
        return self.visit(node)

    @singledispatchmethod
    def visit(self, node):
        super().visit(node)

    @staticmethod
    def _infer_compare_type(ltype, rtype):
        # check for issues
        bitwidth = max(ltype.bits, rtype.bits)
        t = predicate_from_spec(bitwidth)
        return t

    def _infer_divide_type(self, node):
        # weird one
        ltype = self.visit(node.left)
        rtype = self.visit(node.right)
        if isinstance(ltype, ir.PredicateType) or isinstance(rtype, ir.PredicateType):
            msg = f"No support for division on boolean or predicate types {ltype}, {rtype}."
            raise CompilerError(msg)
        # promote types doesn't work perfectly here
        np_ltype = ir.by_ir_type[ltype]
        np_rtype = ir.by_ir_type[rtype]
        larr = np.ones(1, dtype=np_ltype)
        rarr = np.ones(1, dtype=np_rtype)
        repl = larr / rarr
        repl_type = ir.by_input_dtype.get(repl.dtype)
        if repl_type is None:
            msg = f"No supported type for numpy type {repl.dtype}."
            raise CompilerError(msg)
        return repl_type

    @visit.register
    def _(self, node: ir.AffineSeq):
        return node

    @visit.register
    def _(self, node: ir.Subscript):
        # find number of dims reduced by subscript
        reduce_by = 0
        base = node
        while isinstance(base, ir.Subscript):
            if isinstance(node.index, ir.Tuple):
                reduce_by += sum(not isinstance(i, ir.Slice) for i in node.index.subexprs)
            elif not isinstance(node.index, ir.Slice):
                # simple index
                reduce_by += 1
            base = base.value

        array_type = self.visit(node.value)
        if not isinstance(array_type, ir.ArrayType):
            # would be better not to raise here..
            msg = f"Cannot subscript non-array type {array_type}."
            raise CompilerError(msg)
        if isinstance(node.index, ir.Slice):
            t = array_type
        else:
            # single index
            ndims = array_type.ndims - reduce_by
            if ndims == 0:
                t = array_type.dtype
            else:
                t = ir.ArrayType(ndims, array_type.dtype)
        return t

    @visit.register
    def _(self, node: ir.Constant):
        np_type = type(node.value)
        dtype = np.dtype(np_type)
        t = ir.by_input_dtype.get(dtype)
        return t

    @visit.register
    def _(self, node: ir.NameRef):
        return self.symbols.check_type(node)

    @visit.register
    def _(self, node: ir.BinOp):
        ltype = self.visit(node.left)
        rtype = self.visit(node.right)
        if rtype is None:
            rtype = self.visit(node.right)
        if ((isinstance(ltype, ir.PredicateType) or isinstance(rtype, ir.PredicateType))
                or (isinstance(node, (ir.LSHIFT, ir.RSHIFT, ir.BITOR, ir.BITAND, ir.BITXOR))
                    and (not isinstance(ltype, ir.IntegerType) or not isinstance(rtype, ir.IntegerType)))):
            lname = ltype.type_name
            rname = rtype.type_name
            msg = f"No method available to apply {type(node)} for operand types {lname}, {rname}"
            raise CompilerError(msg)
        np_ltype = ir.by_ir_type.get(ltype)
        np_rtype = ir.by_ir_type.get(rtype)
        if np_rtype is None:
            msg = f"rtype: {rtype}"
            raise CompilerError(msg)
        # Check numpy type promotion
        # error message from numpy is uninformative here..
        try:
            np_result_type = np.promote_types(np_ltype, np_rtype)
        except TypeError:
            msg = f"Unable to deduce binop result type for types {np_ltype} and {np_rtype}."
            raise CompilerError(msg)
        # check that we have a supported IR type
        result_type = ir.by_input_dtype.get(np_result_type)
        if result_type is None:
            msg = f"No supported IR type corresponds to {np_result_type}."
            raise CompilerError(msg)
        return result_type

    @visit.register
    def _(self, node: ir.TRUEDIV):
        return self._infer_divide_type(node)

    @visit.register
    def _(self, node: ir.MOD):
        return self._infer_divide_type(node)

    @visit.register
    def _(self, node: ir.USUB):
        return node.operand

    @visit.register
    def _(self, node: ir.UNOT):
        operand_type = self.visit(node.operand)
        if operand_type.boolean or not operand_type.integral:
            # try to get numpy type
            np_type = ir.by_ir_type.get(operand_type)
            t = np_type if np_type is not None else operand_type
            msg = f"No method to invert type {t}."
            raise CompilerError(msg)

    @visit.register
    def _(self, node: ir.NOT):
        base_type = self.visit(node.operand)
        tt = truth_type_from_type(base_type)
        return tt

    @visit.register
    def _(self, node: ir.EQ):
        ltype = self.visit(node.left)
        rtype = self.visit(node.right)
        if isinstance(ltype, ir.PredicateType) != isinstance(rtype, ir.PredicateType):
            msg = f"Equality comparison is unsupported between boolean and other types, {ltype}, {rtype}."
            raise CompilerError(msg)
        return self._infer_compare_type(ltype, rtype)

    @visit.register
    def _(self, node: ir.NE):
        ltype = self.visit(node.left)
        rtype = self.visit(node.right)
        if isinstance(ltype, ir.PredicateType) != isinstance(rtype, ir.PredicateType):
            msg = f"Equality comparison is unsupported between boolean and other types, {ltype}, {rtype}."
            raise CompilerError(msg)
        return self._infer_compare_type(ltype, rtype)

    @visit.register
    def _(self, node: ir.CompareOp):
        ltype = self.visit(node.left)
        rtype = self.visit(node.right)
        for t in (ltype, rtype):
            if isinstance(t, ir.ArrayType):
                msg = f"Comparisons are supported for array types: {node}."
                raise CompilerError(msg)
            elif t.is_predicate:
                msg = f"Comparisons other == and != comparisons are unsupported for boolean types."
                raise CompilerError(msg)
        # check for floating point types and largest bit width
        return self._infer_compare_type(ltype, rtype)

    @visit.register
    def _(self, node: ir.BoolOp):
        operand_types = []
        for operand in node.operands:
            type_ = self.visit(operand)
            if isinstance(type_, ir.ArrayType):
                msg = f"Cannot truth test array type {operand}."
                raise CompilerError(msg)
            operand_types.append(type_)
        bits = 0
        for t in operand_types:
            t = predicate_from_spec(t.bits)
            bits = max(bits, t.bits)
        t = predicate_from_spec(bits)
        return t


class TypeChecks(StmtVisitor):

    def __init__(self, syms):
        self.type_check = ExprTypeInfer(syms)

    def __call__(self, entry):
        self.visit(entry)

    @singledispatchmethod
    def visit(self, node):
        super().visit(node)

    @visit.register
    def _(self, node: ir.Assign):
        tt = self.type_check(node.target)
        vt = self.type_check(node.value)
        # check for match or castable
        if tt != vt:
            # check if can cast
            msg = f"Cannot cast {tt} to {vt}."
            raise CompilerError(msg)

    @visit.register
    def _(self, node: ir.SingleExpr):
        # trigger type faults
        self.type_check(node.expr)

    @visit.register
    def _(self, node: ir.IfElse):
        # node.test check isn't explicitly used
        # it's needed to ensure that we can process
        # the corresponding expressions
        self.type_check(node.test)
        self.visit(node.if_branch)
        self.visit(node.else_branch)

    @visit.register
    def _(self, node: ir.ForLoop):
        for target, value in unpack_iterated(node.target, node.iterable):
            tt = self.type_check(target)
            vt = self.type_check(value)
            # check that they match
            if tt != vt:
                # check if can cast
                msg = f"Cannot cast {tt} to {vt}."
                raise CompilerError(msg)
        self.visit(node.body)

    @visit.register
    def _(self, node: ir.WhileLoop):
        self.type_check(node.test)
        self.visit(node.body)


class TypeInfer(StmtVisitor):

    def __init__(self):
        pass

